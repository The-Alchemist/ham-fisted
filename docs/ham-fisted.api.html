<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>ham-fisted.api documentation</title><script async="true" src="https://www.googletagmanager.com/gtag/js?id=G-XJYNJF48RM"></script><script>window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XJYNJF48RM');</script><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Ham-Fisted</span> <span class="project-version">1.000-alpha-1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 current"><a href="ham-fisted.api.html"><div class="inner"><span>ham-fisted.api</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="ham-fisted.api.html#var--.3Ebi-function"><div class="inner"><span>-&gt;bi-function</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var--.3Efunction"><div class="inner"><span>-&gt;function</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-as-immut-vals"><div class="inner"><span>as-immut-vals</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-assoc"><div class="inner"><span>assoc</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-assoc.21"><div class="inner"><span>assoc!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-assoc-in"><div class="inner"><span>assoc-in</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-clear.21"><div class="inner"><span>clear!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-clear-memoized-fn.21"><div class="inner"><span>clear-memoized-fn!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-compute.21"><div class="inner"><span>compute!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-compute-if-absent.21"><div class="inner"><span>compute-if-absent!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-compute-if-present.21"><div class="inner"><span>compute-if-present!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-conj.21"><div class="inner"><span>conj!</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-difference"><div class="inner"><span>difference</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-empty-map"><div class="inner"><span>empty-map</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-empty-set"><div class="inner"><span>empty-set</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-empty-vec"><div class="inner"><span>empty-vec</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-equal-hash-provider"><div class="inner"><span>equal-hash-provider</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-equiv-hash-provider"><div class="inner"><span>equiv-hash-provider</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-frequencies"><div class="inner"><span>frequencies</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-get-in"><div class="inner"><span>get-in</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-group-by"><div class="inner"><span>group-by</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-hash-map"><div class="inner"><span>hash-map</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-immut-list"><div class="inner"><span>immut-list</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-immut-map"><div class="inner"><span>immut-map</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-immut-set"><div class="inner"><span>immut-set</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-intersection"><div class="inner"><span>intersection</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-into"><div class="inner"><span>into</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-java-concurrent-hashmap"><div class="inner"><span>java-concurrent-hashmap</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-java-hashmap"><div class="inner"><span>java-hashmap</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-java-hashset"><div class="inner"><span>java-hashset</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-map-factory"><div class="inner"><span>map-factory</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-map-intersection"><div class="inner"><span>map-intersection</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-map-union"><div class="inner"><span>map-union</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-map-union-java-hashmap"><div class="inner"><span>map-union-java-hashmap</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-mapmap"><div class="inner"><span>mapmap</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-memoize"><div class="inner"><span>memoize</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-merge"><div class="inner"><span>merge</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-merge-with"><div class="inner"><span>merge-with</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-mut-list"><div class="inner"><span>mut-list</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-mut-map"><div class="inner"><span>mut-map</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-mut-set"><div class="inner"><span>mut-set</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-obj-ary"><div class="inner"><span>obj-ary</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-subvec"><div class="inner"><span>subvec</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-union"><div class="inner"><span>union</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-union-reduce-java-hashmap"><div class="inner"><span>union-reduce-java-hashmap</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-union-reduce-maps"><div class="inner"><span>union-reduce-maps</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-update"><div class="inner"><span>update</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-update-in"><div class="inner"><span>update-in</span></div></a></li><li class="depth-1"><a href="ham-fisted.api.html#var-update-values"><div class="inner"><span>update-values</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">ham-fisted.api</h1><div class="doc"><div class="markdown"><p>Fast mutable and immutable associative data structures based on bitmap trie
hashmaps. Mutable pathways implement the <code>java.util.Map</code> or <code>Set</code> interfaces
including in-place update features such as compute or computeIfPresent.</p>
<p>Mutable maps or sets can be turned into their immutable counterparts via the
Clojure <code>persistent!</code> call. This allows working in a mutable space for
convenience and performance then switching to an immutable pathway when
necessary. Note: after <code>persistent!</code> one should never backdoor mutate map or
set again as this will break the contract of immutability.  Immutable
data structures also support conversion to transient via <code>transient</code>.</p>
<p>Map keysets (<code>.keySet</code>) are full <code>PersistentHashSet</code>s of keys.</p>
<p>Maps and sets support metadata but setting the metadata on mutable objects
returns a new mutable object that shares the backing store leading to possible
issues. Metadata is transferred to the persistent versions of the
mutable/transient objects upon <code>persistent!</code>.</p>
<p>Very fast versions of union, difference and intersection are provided for maps
and sets with the map version of union and difference requiring an extra
argument, a <code>java.util.BiFunction</code> or an <code>IFn</code> taking 2 arguments to merge the
left and right sides into the final map. These implementations of union,
difference, and intersection are the fastest implementation of these
operations we know of on the JVM.</p>
<p>Additionally a fast value update pathway is provided, enabling quickly
updating all the values in a given map. Additionally, a new map primitive</p>
<ul>
<li><a href="ham-fisted.api.html#var-mapmap">mapmap</a> - allows transforming a given map into a new map quickly by
mapping across all the entries.</li>
</ul>
<p>Unlike the standard Java objects, mutation-via-iterator is not supported.</p>
</div></div><div class="public anchor" id="var--.3Ebi-function"><h3>-&gt;bi-function</h3><div class="usage"><code>(-&gt;bi-function cljfn)</code></div><div class="doc"><div class="markdown"><p>Convert an object to a java.util.BiFunction. Object can either already be a
bi-function or an IFn to be invoked with 2 arguments.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L397">view source</a></div></div><div class="public anchor" id="var--.3Efunction"><h3>-&gt;function</h3><div class="usage"><code>(-&gt;function cljfn)</code></div><div class="doc"><div class="markdown"><p>Convert an object to a java Function. Object can either already be a
Function or an IFn to be invoked.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L406">view source</a></div></div><div class="public anchor" id="var-as-immut-vals"><h3>as-immut-vals</h3><div class="usage"><code>(as-immut-vals item)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L466">view source</a></div></div><div class="public anchor" id="var-assoc"><h3>assoc</h3><div class="usage"><code>(assoc m a b)</code><code>(assoc m a b c d)</code><code>(assoc m a b c d e f)</code><code>(assoc m a b c d e f g h)</code><code>(assoc m a b c d e f g h &amp; args)</code></div><div class="doc"><div class="markdown"><p>Drop in faster or equivalent replacement for clojure.core/assoc especially for
small numbers of keyval pairs.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L86">view source</a></div></div><div class="public anchor" id="var-assoc.21"><h3>assoc!</h3><div class="usage"><code>(assoc! obj k v)</code></div><div class="doc"><div class="markdown"><p>assoc! that works on transient collections, implementations of java.util.Map and
RandomAccess java.util.List implementations.  Be sure to keep track of return value
as some implementations return a different return value than the first argument.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L365">view source</a></div></div><div class="public anchor" id="var-assoc-in"><h3>assoc-in</h3><h4 class="type">macro</h4><div class="usage"><code>(assoc-in m ks v)</code></div><div class="doc"><div class="markdown"><p>Assoc-in - more efficient replacement if ks is a known compile time constant
or a vector.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L900">view source</a></div></div><div class="public anchor" id="var-clear.21"><h3>clear!</h3><div class="usage"><code>(clear! map-or-coll)</code></div><div class="doc"><div class="markdown"><p>Mutably clear a map, set, list or implementation of java.util.Collection.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L444">view source</a></div></div><div class="public anchor" id="var-clear-memoized-fn.21"><h3>clear-memoized-fn!</h3><div class="usage"><code>(clear-memoized-fn! memoize-fn)</code></div><div class="doc"><div class="markdown"><p>Clear a memoized function backing store.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L860">view source</a></div></div><div class="public anchor" id="var-compute.21"><h3>compute!</h3><div class="usage"><code>(compute! m k bfn)</code></div><div class="doc"><div class="markdown"><p>Compute a new value in a map derived from an existing value.  bfn gets passed k, v where k
may be nil.  If the function returns nil the corresponding key is removed from the map.</p>
<p>See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#compute-K-java.util.function.BiFunction-">Map.compute</a></p>
<p>An example <code>bfn</code> for counting occurrences would be <code>#(if % (inc (long %)) 1)</code>.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L415">view source</a></div></div><div class="public anchor" id="var-compute-if-absent.21"><h3>compute-if-absent!</h3><div class="usage"><code>(compute-if-absent! m k bfn)</code></div><div class="doc"><div class="markdown"><p>Compute a value if absent from the map.  Useful for memoize-type operations.  Must use
mutable maps.  bfn gets passed k.</p>
<p>See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-">map.computeIfAbsent</a></p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L435">view source</a></div></div><div class="public anchor" id="var-compute-if-present.21"><h3>compute-if-present!</h3><div class="usage"><code>(compute-if-present! m k bfn)</code></div><div class="doc"><div class="markdown"><p>Compute a new value if the value already exists and is non-nil in the hashmap.  Must use
mutable maps.  bfn gets passed k, v where v is non-nil.</p>
<p>See <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfPresent-K-java.util.function.BiFunction-">Map.computeIfPresent</a></p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L426">view source</a></div></div><div class="public anchor" id="var-conj.21"><h3>conj!</h3><div class="usage"><code>(conj! obj val)</code></div><div class="doc"><div class="markdown"><p>conj! that works on transient collections, implementations of java.util.Set and
RandomAccess java.util.List implementations.  Be sure to keep track of return value
as some implementations return a different return value than the first argument.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L381">view source</a></div></div><div class="public anchor" id="var-difference"><h3>difference</h3><div class="usage"><code>(difference map1 map2)</code></div><div class="doc"><div class="markdown"><p>Take the difference of two maps (or sets) returning a new map.  Return value is a map1
(or set1) without the keys present in map2.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L614">view source</a></div></div><div class="public anchor" id="var-empty-map"><h3>empty-map</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L72">view source</a></div></div><div class="public anchor" id="var-empty-set"><h3>empty-set</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L73">view source</a></div></div><div class="public anchor" id="var-empty-vec"><h3>empty-vec</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L74">view source</a></div></div><div class="public anchor" id="var-equal-hash-provider"><h3>equal-hash-provider</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Hash provider based on Object.hashCode and Object.equals - this is
the same pathway that <code>java.util.HashMap</code> uses and is the overall the fastest
hash provider.  Hash-based data structures based on this hash provider will be
faster to create and access but will not use the hasheq pathway. This is fine
for integer keys, strings, keywords, and symbols, but differs for objects such
as doubles, floats, and BigDecimals. This is the default hash provider.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L57">view source</a></div></div><div class="public anchor" id="var-equiv-hash-provider"><h3>equiv-hash-provider</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Hash provider based on Clojure's hasheq and equiv pathways - the
same algorithm that Clojure's persistent data structures use. This hash
provider is somewhat (&lt;2x) slower than the <a href="ham-fisted.api.html#var-equal-hash-provider">equal-hash-provider</a>.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L52">view source</a></div></div><div class="public anchor" id="var-frequencies"><h3>frequencies</h3><div class="usage"><code>(frequencies coll)</code></div><div class="doc"><div class="markdown"><p>Faster (9X or so), implementation of clojure.core/frequencies.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L774">view source</a></div></div><div class="public anchor" id="var-get-in"><h3>get-in</h3><h4 class="type">macro</h4><div class="usage"><code>(get-in m ks default-value)</code><code>(get-in m ks)</code></div><div class="doc"><div class="markdown"><p>get-in drop-in more efficient replacement if ks is a vector especially if ks
is known at compile time.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L945">view source</a></div></div><div class="public anchor" id="var-group-by"><h3>group-by</h3><div class="usage"><code>(group-by f coll)</code></div><div class="doc"><div class="markdown"><p>Group items in collection by the grouping function f.  Returns persistent map of
keys to persistent vectors.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L1099">view source</a></div></div><div class="public anchor" id="var-hash-map"><h3>hash-map</h3><div class="usage"><code>(hash-map)</code><code>(hash-map a b)</code><code>(hash-map a b c d)</code><code>(hash-map a b c d e f)</code><code>(hash-map a b c d e f g h)</code><code>(hash-map a b c d e f g h i j)</code><code>(hash-map a b c d e f g h i j k l)</code><code>(hash-map a b c d e f g h i j k l m n)</code><code>(hash-map a b c d e f g h i j k l m n o p)</code><code>(hash-map a b c d e f g h i j k l m n o p &amp; args)</code></div><div class="doc"><div class="markdown"><p>Drop-in replacement to Clojure's hash-map function.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L264">view source</a></div></div><div class="public anchor" id="var-immut-list"><h3>immut-list</h3><div class="usage"><code>(immut-list)</code><code>(immut-list data)</code></div><div class="doc"><div class="markdown"><p>Create a mutable java list that is in-place convertible to a persistent list</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L357">view source</a></div></div><div class="public anchor" id="var-immut-map"><h3>immut-map</h3><div class="usage"><code>(immut-map)</code><code>(immut-map data)</code><code>(immut-map options data)</code></div><div class="doc"><div class="markdown"><p>Create an immutable map.  This object supports conversion to a transient map via
Clojure's <code>transient</code> function.  Duplicate keys are treated as if by assoc.</p>
<p>If data is an object array it is treated as a flat key-value list which is distinctly
different than how conj! treats object arrays.  You have been warned.</p>
<p>Options:</p>
<ul>
<li><code>:hash-provider</code> - An implementation of <code>BitmapTrieCommon$HashProvider</code>.  Defaults to
the <a href="ham-fisted.api.html#var-equal-hash-provider">equal-hash-provider</a>.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-clojure">ham-fisted.api&gt; (immut-map (obj-ary :a 1 :b 2 :c 3 :d 4))
{:a 1, :b 2, :c 3, :d 4}
ham-fisted.api&gt; (type *1)
ham_fisted.PersistentArrayMap
ham-fisted.api&gt; (immut-map (obj-ary :a 1 :b 2 :c 3 :d 4 :e 5))
{:d 4, :b 2, :c 3, :a 1, :e 5}
ham-fisted.api&gt; (type *1)
ham_fisted.PersistentHashMap
ham-fisted.api&gt; (immut-map [[:a 1][:b 2][:c 3][:d 4][:e 5]])
{:d 4, :b 2, :c 3, :a 1, :e 5}
ham-fisted.api&gt; (type *1)
ham_fisted.PersistentHashMap
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L227">view source</a></div></div><div class="public anchor" id="var-immut-set"><h3>immut-set</h3><div class="usage"><code>(immut-set)</code><code>(immut-set data)</code><code>(immut-set options data)</code></div><div class="doc"><div class="markdown"><p>Create an immutable hashset based on the bitmap trie.  This object supports conversion
to transients via <code>transient</code>.</p>
<p>Options:</p>
<ul>
<li><code>:hash-provider</code> - An implementation of <code>BitmapTrieCommon$HashProvider</code>.  Defaults to
the <a href="ham-fisted.api.html#var-equal-hash-provider">equal-hash-provider</a>.</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L331">view source</a></div></div><div class="public anchor" id="var-intersection"><h3>intersection</h3><div class="usage"><code>(intersection s1 s2)</code></div><div class="doc"><div class="markdown"><p>Intersect the keyspace of set1 and set2 returning a new set.  Also works if s1 is a
map and s2 is a set - the map is trimmed to the intersecting keyspace of s1 and s2.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L665">view source</a></div></div><div class="public anchor" id="var-into"><h3>into</h3><div class="usage"><code>(into container data)</code><code>(into container xform data)</code></div><div class="doc"><div class="markdown"><p>Like clojure.core/into, but also designed to handle editable collections,
transients, and base java.util.Map, List and Set containers.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L186">view source</a></div></div><div class="public anchor" id="var-java-concurrent-hashmap"><h3>java-concurrent-hashmap</h3><div class="usage"><code>(java-concurrent-hashmap)</code><code>(java-concurrent-hashmap data)</code></div><div class="doc"><div class="markdown"><p>Create a java concurrent hashmap which is still the fastest possible way to solve a
few concurrent problems.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L311">view source</a></div></div><div class="public anchor" id="var-java-hashmap"><h3>java-hashmap</h3><div class="usage"><code>(java-hashmap)</code><code>(java-hashmap data)</code></div><div class="doc"><div class="markdown"><p>Create a java.util.HashMap.  Duplicate keys are treated as if map was created by assoc.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L292">view source</a></div></div><div class="public anchor" id="var-java-hashset"><h3>java-hashset</h3><div class="usage"><code>(java-hashset)</code><code>(java-hashset data)</code></div><div class="doc"><div class="markdown"><p>Create a java hashset which is still the fastest possible way to solve a few problems.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L344">view source</a></div></div><div class="public anchor" id="var-map-factory"><h3>map-factory</h3><div class="usage"><code>(map-factory keys)</code></div><div class="doc"><div class="markdown"><p>Create a factory to quickly produce maps with a fixed set of keys but arbitrary
values.  This version takes a vector or sequence of keys and returns and IFn that
takes a vector, object-array, or sequence of values.  The most efficient pathway will be
if values are already in an object array.</p>
<p>The factory produces PersistentHashMaps.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L869">view source</a></div></div><div class="public anchor" id="var-map-intersection"><h3>map-intersection</h3><div class="usage"><code>(map-intersection bfn map1 map2)</code></div><div class="doc"><div class="markdown"><p>Intersect the keyspace of map1 and map2 returning a new map.  Each value is the result
of bfn applied to the map1-value and map2-value, respectively.  See documentation for
<a href="ham-fisted.api.html#var-map-union">map-union</a>.</p>
<p>Clojure's <code>merge</code> functionality can be duplicate via:</p>
<pre><code class="language-clojure">(map-intersection (fn [lhs rhs] rhs) map1 map2)
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L640">view source</a></div></div><div class="public anchor" id="var-map-union"><h3>map-union</h3><div class="usage"><code>(map-union bfn map1 map2)</code></div><div class="doc"><div class="markdown"><p>Take the union of two maps returning a new map.  bfn is a function that takes 2 arguments,
map1-val and map2-val and returns a new value.  Has fallback if map1 and map2 aren't backed
by bitmap tries.</p>
<ul>
<li><code>bfn</code> - A function taking two arguments and returning one.  <code>+</code> is a fine choice.</li>
<li><code>map1</code> - the lhs of the union.</li>
<li><code>map2</code> - the rhs of the union.</li>
</ul>
<p>Returns a persistent map.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L491">view source</a></div></div><div class="public anchor" id="var-map-union-java-hashmap"><h3>map-union-java-hashmap</h3><div class="usage"><code>(map-union-java-hashmap bfn lhs rhs)</code></div><div class="doc"><div class="markdown"><p>Take the union of two maps returning a new map.  See documentation for <a href="map-union">map-union</a>.
Returns a java.util.HashMap.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L551">view source</a></div></div><div class="public anchor" id="var-mapmap"><h3>mapmap</h3><div class="usage"><code>(mapmap map-fn src-map)</code></div><div class="doc"><div class="markdown"><p>Clojure's missing piece. Map over the data in src-map, which must be a map or
sequence of pairs, using map-fn. map-fn must return either a new key-value
pair or nil. Then, remove nil pairs, and return a new map. If map-fn returns
more than one pair with the same key later pair will overwrite the earlier
pair.</p>
<p>Logically the same as:</p>
<pre><code class="language-clojure">(-&gt;&gt; (map map-fn src-map) (remove nil?) (into {}))
</code></pre>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L712">view source</a></div></div><div class="public anchor" id="var-memoize"><h3>memoize</h3><div class="usage"><code>(memoize memo-fn)</code></div><div class="doc"><div class="markdown"><p>Efficient thread-safe version of clojure.core/memoize.  Unlike
clojure.core/memoize this version guarantees memo-fn will be called exactly
once per argument vector even in high-contention environments.</p>
<p>Also see <a href="ham-fisted.api.html#var-clear-memoized-fn.21">clear-memoized-fn!</a> to mutably clear the backing store.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L828">view source</a></div></div><div class="public anchor" id="var-merge"><h3>merge</h3><div class="usage"><code>(merge)</code><code>(merge m1)</code><code>(merge m1 m2)</code><code>(merge m1 m2 &amp; args)</code></div><div class="doc"><div class="markdown"><p>Merge 2 maps with the rhs values winning any intersecting keys.  Uses map-union
with <code>BitmapTrieCommon/rhsWins</code>.</p>
<p>Returns a new persistent map.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L797">view source</a></div></div><div class="public anchor" id="var-merge-with"><h3>merge-with</h3><div class="usage"><code>(merge-with f)</code><code>(merge-with f m1)</code><code>(merge-with f m1 m2)</code><code>(merge-with f m1 m2 &amp; args)</code></div><div class="doc"><div class="markdown"><p>Merge (union) any number of maps using <code>f</code> as the merge operator.  <code>f</code> gets passed two
arguments, lhs-val and rhs-val and must return a new value.</p>
<p>Returns a new persistent map.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L813">view source</a></div></div><div class="public anchor" id="var-mut-list"><h3>mut-list</h3><div class="usage"><code>(mut-list)</code><code>(mut-list data)</code></div><div class="doc"><div class="markdown"><p>Create a mutable java list that is in-place convertible to a persistent list</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L350">view source</a></div></div><div class="public anchor" id="var-mut-map"><h3>mut-map</h3><div class="usage"><code>(mut-map)</code><code>(mut-map data)</code><code>(mut-map options data)</code></div><div class="doc"><div class="markdown"><p>Create a mutable implementation of java.util.Map.  This object efficiently implements
ITransient map so you can use assoc! and persistent! on it but you can additionally use
operations such as put!, remove!, compute-at! and compute-if-absent!.  You can create
a persistent hashmap via the clojure <code>persistent!</code> call.</p>
<p>Options:</p>
<ul>
<li><code>:hash-provider</code> - An implementation of <code>BitmapTrieCommon$HashProvider</code>.  Defaults to
the <a href="ham-fisted.api.html#var-equal-hash-provider">equal-hash-provider</a>.</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L210">view source</a></div></div><div class="public anchor" id="var-mut-set"><h3>mut-set</h3><div class="usage"><code>(mut-set)</code><code>(mut-set data)</code><code>(mut-set options data)</code></div><div class="doc"><div class="markdown"><p>Create a mutable hashset based on the bitmap trie. You can create a persistent hashset via
the clojure <code>persistent!</code> call.</p>
<p>Options:</p>
<ul>
<li><code>:hash-provider</code> - An implementation of <code>BitmapTrieCommon$HashProvider</code>.  Defaults to
the <a href="ham-fisted.api.html#var-equal-hash-provider">equal-hash-provider</a>.</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L318">view source</a></div></div><div class="public anchor" id="var-obj-ary"><h3>obj-ary</h3><div class="usage"><code>(obj-ary)</code><code>(obj-ary v0)</code><code>(obj-ary v0 v1)</code><code>(obj-ary v0 v1 v2)</code><code>(obj-ary v0 v1 v2 v3)</code><code>(obj-ary v0 v1 v2 v3 v4)</code><code>(obj-ary v0 v1 v2 v3 v4 v5)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 args)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 v6 v7)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 v6 v7 v8 v9)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15)</code><code>(obj-ary v0 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 args)</code></div><div class="doc"><div class="markdown"><p>As quickly as possible, produce an object array from these inputs.  Very fast for arities
&lt;= 6.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L159">view source</a></div></div><div class="public anchor" id="var-subvec"><h3>subvec</h3><div class="usage"><code>(subvec m sidx eidx)</code><code>(subvec m sidx)</code></div><div class="doc"><div class="markdown"><p>More general and faster version of subvec.  Works for any java list implementation
including persistent vectors.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L1090">view source</a></div></div><div class="public anchor" id="var-union"><h3>union</h3><div class="usage"><code>(union s1 s2)</code></div><div class="doc"><div class="markdown"><p>Union of two sets or two maps.  When two maps are provided the right hand side
wins in the case of an intersection.</p>
<p>Result is either a set or a map, depending on if s1 is a set or map.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L530">view source</a></div></div><div class="public anchor" id="var-union-reduce-java-hashmap"><h3>union-reduce-java-hashmap</h3><div class="usage"><code>(union-reduce-java-hashmap bfn maps options)</code><code>(union-reduce-java-hashmap bfn maps)</code></div><div class="doc"><div class="markdown"><p>Do an efficient union of many maps into a single java.util.HashMap.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L594">view source</a></div></div><div class="public anchor" id="var-union-reduce-maps"><h3>union-reduce-maps</h3><div class="usage"><code>(union-reduce-maps bfn maps options)</code><code>(union-reduce-maps bfn maps)</code></div><div class="doc"><div class="markdown"><p>Do an efficient union reduction across many maps using bfn to update values.  See
documentation for <a href="map-union">map-union</a>.  If any of the input maps are not implementations provided
by this library this falls backs to <code>(reduce (partial union-maps bfn) maps)</code>.</p>
<p>This operator is an example of how to write a parallelized map reduction but it itself
is only faster when you have many large maps to union into a final result.  <a href="map-union">map-union</a>
is generally faster in normal use cases.</p>
<p>Options:</p>
<ul>
<li><code>:force-serial?</code> - Force the use of a serial reduction algorithm.</li>
<li><code>:executor-service</code> - Use this executor service.  Falls back to ForkJoinPool/commonPool
when not provided.</li>
<li><code>:parallelism</code> - Use this many threads, must be a number from <a href="1-1024">1-1024</a> and defaults to
ForkJoinPool/getCommonPoolParallelism.</li>
</ul>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L563">view source</a></div></div><div class="public anchor" id="var-update"><h3>update</h3><div class="usage"><code>(update m k f)</code><code>(update m k f a)</code><code>(update m k f a b)</code><code>(update m k f a b c)</code><code>(update m k f a b c d)</code><code>(update m k f a b c d e)</code><code>(update m k f a b c d e f)</code><code>(update m k f a b c d e f &amp; args)</code></div><div class="doc"><div class="markdown"><p>Slightly faster version of clojure.core/update when you have persistent maps from this
library.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L1022">view source</a></div></div><div class="public anchor" id="var-update-in"><h3>update-in</h3><div class="usage"><code>(update-in m ks f)</code><code>(update-in m ks f a)</code><code>(update-in m ks f a b)</code><code>(update-in m ks f a b c)</code><code>(update-in m ks f a b c d)</code><code>(update-in m ks f a b c d e)</code><code>(update-in m ks f a b c d e f)</code><code>(update-in m ks f a b c d e f &amp; args)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L1071">view source</a></div></div><div class="public anchor" id="var-update-values"><h3>update-values</h3><div class="usage"><code>(update-values map bfn)</code></div><div class="doc"><div class="markdown"><p>Immutably update all values in the map returning a new map.  bfn takes 2 arguments,
k,v and returns a new v. Returns new persistent map.</p>
</div></div><div class="src-link"><a href="https://github.com/cnuernber/ham-fisted/blob/master/src/ham_fisted/api.clj#L687">view source</a></div></div></div></body></html>